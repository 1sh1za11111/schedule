<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Schedule & Task App (予実管理版)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; background-color: #F4F5F7; }
    
    /* ログイン画面 */
    #login-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #4F46E5; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
    .login-box { background: white; padding: 40px; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); text-align: center; }
    .login-box h2 { margin-top: 0; color: #1F2937; }
    .login-box input { padding: 10px; font-size: 16px; width: 200px; margin-bottom: 20px; border: 1px solid #E5E7EB; border-radius: 6px; display: block; margin: 10px auto 20px; }
    .login-box button { padding: 10px 30px; background: #10B981; color: white; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: 0.2s; }
    .login-box button:hover { background: #059669; }
    .error-msg { color: red; font-size: 14px; height: 20px; margin-bottom: 10px; }
    .reset-link { margin-top: 20px; font-size: 12px; color: #ccc; text-decoration: underline; cursor: pointer; }

    /* モーダル */
    #modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; }
    .modal-content { background: white; width: 400px; padding: 20px; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); position: relative; }
    .modal-header { height: 10px; border-radius: 12px 12px 0 0; margin: -20px -20px 20px -20px; background: #ccc; transition: background 0.3s; }
    .form-group { margin-bottom: 15px; }
    .form-group label { display: block; font-size: 12px; color: #6B7280; margin-bottom: 5px; }
    .form-group input, .form-group textarea { width: 100%; padding: 8px; border: 1px solid #E5E7EB; border-radius: 6px; font-size: 14px; box-sizing: border-box; font-family: inherit; }
    .form-group textarea { height: 60px; resize: none; }
    .time-inputs { display: flex; align-items: center; gap: 10px; }
    .color-picker { display: flex; gap: 8px; margin-top: 5px; }
    .color-circle { width: 24px; height: 24px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: transform 0.1s; }
    .color-circle:hover { transform: scale(1.1); }
    .color-circle.selected { border-color: #1F2937; box-shadow: 0 0 0 2px rgba(0,0,0,0.1); }
    .modal-actions { display: flex; justify-content: space-between; margin-top: 20px; }
    .btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-size: 14px; }
    .btn-save { background: #4F46E5; color: white; }
    .btn-close { background: #E5E7EB; color: #1F2937; }
    .btn-delete { background: #FEE2E2; color: #EF4444; }
    #file-input { display: none; }
  </style>
</head>
<body>

  <div id="login-screen">
    <div class="login-box">
      <h2>Welcome</h2>
      <div id="login-error" class="error-msg"></div>
      <input type="password" id="password-input" placeholder="Password">
      <button onclick="checkLogin()">Login</button>
      <div class="reset-link" onclick="resetAllData()">画面がおかしい場合はリセット</div>
    </div>
  </div>

  <input type="file" id="file-input" accept=".ics">

  <div id="modal-overlay">
    <div class="modal-content">
      <div id="modal-header-bar" class="modal-header"></div>
      <div class="form-group">
        <label id="label-title">タイトル</label>
        <input type="text" id="input-title">
      </div>
      <div class="form-group" id="group-time">
        <label>時間 (例: 13:00)</label>
        <div class="time-inputs">
          <input type="time" id="input-start">
          <span>▶</span>
          <input type="time" id="input-end">
        </div>
      </div>
      <div class="form-group" id="group-deadline" style="display:none;">
        <label>締切日 (↑↓キーで変更可)</label>
        <input type="date" id="input-deadline">
      </div>
      <div class="form-group">
        <label>カラー</label>
        <div class="color-picker" id="color-picker"></div>
      </div>
      <div class="form-group">
        <label>詳細メモ</label>
        <textarea id="input-memo"></textarea>
      </div>
      <div class="modal-actions">
        <button class="btn btn-delete" onclick="deleteItem()">削除</button>
        <div>
          <button class="btn btn-close" onclick="closeModal()">閉じる</button>
          <button class="btn btn-save" onclick="saveItem()">保存</button>
        </div>
      </div>
    </div>
  </div>

<script>
// --- クラス定義 (最優先) ---
class Button {
  constructor(l, x, y, w, h, action, alignRight=false, color='#E5E7EB') {
    this.label = l; this.x = x; this.y = y; this.w = w; this.h = h;
    this.action = action; this.alignRight = alignRight; this.color = color;
  }
}

class Event {
  constructor(dateStr, start, duration, title, colorIdx, type=0) {
    this.dateStr = dateStr; 
    this.start = start; 
    this.duration = duration; 
    this.title = title; 
    this.colorIdx = colorIdx;
    this.memo = "";
    this.type = type; // 0:Plan, 1:Actual
  }
}

class Task {
  constructor(title, deadline, memo, colorIdx) {
    this.title = title; 
    this.deadline = deadline; 
    this.memo = memo; 
    this.colorIdx = colorIdx;
    this.completedDate = "";
    this.status = 0; // 0:Doing, 1:Backlog, 2:Done
  }
}

// --- グローバル定数 ---
const CONTROL_H = 60;
const DATE_H = 50;
const SIDEBAR_W = 70;
const HOUR_H = 80;
const RESIZE_MARGIN = 10;

const COL_BG = '#F4F5F7';
const COL_WHITE = '#FFFFFF';
const COL_TEXT_MAIN = '#1F2937';
const COL_TEXT_SUB = '#6B7280';
const COL_LINE = '#E5E7EB';
const COL_ACCENT = '#4F46E5';
const COL_TODAY_BG = '#EEF2FF';

const COL_DOING_BG = '#EEF2FF';
const COL_BACKLOG_BG = '#F3F4F6';
const COL_DONE_BG = '#E5E7EB';

const EVENT_COLORS = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899', '#6366F1', '#6B7280'];
const TASK_COLORS = ['#EF4444', '#F59E0B', '#10B981', '#3B82F6'];

// --- データ変数 ---
let events = [];
let backlogTasks = [];
let doingTasks = [];
let doneTasks = [];

let viewStartDate;
let visibleDays = 4;
let scrollY = -600;
let taskScrollY = 0;
let currentMode = 0; // 0:Calendar, 1:Task
let isLoggedIn = false;

// --- 操作状態 ---
let selectedItem = null;
let creatingEvent = null;
let draggingItem = null;
let dragAction = 0; // 0:None, 1:Create, 2:Move, 3:ResizeTop, 4:ResizeBottom
let dragOffsetTime = 0;
let taskDragOffsetY = 0;
let isTaskDragging = false;
let isEditingDeadline = false;

// --- ログイン処理 ---
function checkLogin() {
  const pass = document.getElementById('password-input').value;
  if (pass === 'jugerun') {
    document.getElementById('login-screen').style.display = 'none';
    isLoggedIn = true;
    loop();
  } else {
    document.getElementById('login-error').innerText = "パスワードが違います";
  }
}

function resetAllData() {
  if(confirm("全てのデータを削除してリセットしますか？")) {
    localStorage.clear();
    location.reload();
  }
}

// --- p5.js Setup ---
function setup() {
  createCanvas(windowWidth, windowHeight);
  if (!isLoggedIn) noLoop();
  
  // ★重要: フォントエラー回避のため標準フォント指定
  textFont('sans-serif');
  
  viewStartDate = new Date();
  viewStartDate.setHours(0,0,0,0);
  
  loadData();
  setupButtons();
  setupKeyEvents();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// --- p5.js Draw ---
function draw() {
  if (!isLoggedIn) return;
  
  background(COL_BG);
  updateCursor();
  drawControlBar();

  if (currentMode === 0) {
    // --- Calendar Mode ---
    let contentH = height - CONTROL_H - DATE_H;
    
    // Header
    push();
    translate(0, CONTROL_H);
    drawDateHeader();
    translate(0, DATE_H);
    
    // Grid & Events
    push();
    translate(0, scrollY);
    drawTimeGrid();
    drawEvents();
    
    // Dragging New Event
    if (dragAction === 1 && creatingEvent) {
      let offset = getDayOffset(new Date(creatingEvent.dateStr));
      if (offset >= 0 && offset < visibleDays) {
        let isSplit = isPastOrToday(new Date(creatingEvent.dateStr));
        drawEventRect(creatingEvent, offset, isSplit);
      }
    }
    pop(); 
    pop();
    
    // マスク用ヘッダー再描画
    drawControlBar(); 

  } else {
    // --- Task Mode ---
    push();
    translate(0, CONTROL_H);
    drawTaskList();
    pop();
    drawControlBar();
  }
}

// --- 描画ロジック ---

function drawControlBar() {
  noStroke(); fill(COL_WHITE); rect(0, 0, width, CONTROL_H);
  fill(0, 20); rect(0, CONTROL_H, width, 1);
  fill(COL_TEXT_MAIN); textAlign(CENTER, CENTER); textSize(18); textStyle(BOLD);
  
  if (currentMode === 0) {
    let d = new Date(viewStartDate);
    text(`${d.getFullYear()}年 ${d.getMonth()+1}月`, width/2, CONTROL_H/2);
    drawButtons();
  } else {
    text("タスクボード (Doing / Backlog / Done)", width/2, CONTROL_H/2);
    drawButtons();
  }
  textStyle(NORMAL);
}

const buttons = [];
function setupButtons() {
  addButton("<<", 20, 15, 40, 30, () => moveDate(-7));
  addButton("<", 70, 15, 40, 30, () => moveDate(-1));
  addButton("今日", 120, 15, 60, 30, () => { viewStartDate = new Date(); viewStartDate.setHours(0,0,0,0); });
  addButton(">", 190, 15, 40, 30, () => moveDate(1));
  addButton(">>", 240, 15, 40, 30, () => moveDate(7));
  addButton("Day", -220, 15, 50, 30, () => visibleDays = 1, true);
  addButton("4 Days", -160, 15, 60, 30, () => visibleDays = 4, true);
  addButton("Week", -90, 15, 50, 30, () => visibleDays = 7, true);
  addButton("ICS出力", -310, 15, 80, 30, exportICS, true, '#10B981');
  addButton("ICS読込", -400, 15, 80, 30, () => document.getElementById('file-input').click(), true, '#3B82F6');
  addButton("モード切替", -530, 15, 120, 30, toggleMode, true, '#6366F1');
}
function addButton(l, x, y, w, h, act, ar=false, col='#E5E7EB') {
  buttons.push(new Button(l, x, y, w, h, act, ar, col));
}
function drawButtons() {
  textSize(12);
  buttons.forEach(b => {
    let bx = b.alignRight ? width + b.x : b.x;
    if (currentMode === 1) { if (['Day', '4 Days', 'Week', '<<', '<', '>', '>>', '今日'].includes(b.label)) return; }
    fill(b.color); noStroke(); rect(bx, b.y, b.w, b.h, 5);
    fill(b.color === '#E5E7EB' ? COL_TEXT_SUB : 'white');
    let txt = b.label;
    if (b.label === "モード切替") txt = currentMode === 0 ? "タスク一覧へ" : "カレンダーへ";
    textAlign(CENTER, CENTER); text(txt, bx + b.w/2, b.y + b.h/2);
  });
}

function drawDateHeader() {
  let colW = (width - SIDEBAR_W) / visibleDays;
  let d = new Date(viewStartDate);
  noStroke();
  for (let i = 0; i < visibleDays; i++) {
    let x = SIDEBAR_W + i * colW;
    let isToday = isSameDate(d, new Date());
    fill(COL_BG); rect(x, 0, colW, DATE_H);
    if (isToday) { fill(COL_ACCENT); ellipse(x + colW/2, DATE_H/2, 30, 30); fill(255); } else { fill(COL_TEXT_SUB); }
    textAlign(CENTER, CENTER); textSize(14); textStyle(BOLD);
    text(`${d.getDate()} (${getDayName(d.getDay())})`, x + colW/2, DATE_H/2);
    textStyle(NORMAL); stroke(COL_LINE); line(x, 0, x, DATE_H);
    d.setDate(d.getDate() + 1);
  }
  fill(COL_BG); rect(0, 0, SIDEBAR_W, DATE_H);
}

// ★ 予実管理対応 TimeGrid
function drawTimeGrid() {
  let colW = (width - SIDEBAR_W) / visibleDays;
  let d = new Date(viewStartDate);
  let today = new Date(); today.setHours(0,0,0,0);
  
  noStroke();
  for (let i = 0; i < visibleDays; i++) {
    let x = SIDEBAR_W + i * colW;
    let isSplit = d <= today; // 今日・過去は分割
    
    if (isSameDate(d, today)) { fill(COL_TODAY_BG); rect(x, 0, colW, 24 * HOUR_H); }
    
    // 分割線
    if (isSplit) {
      stroke(COL_LINE);
      line(x + colW/2, 0, x + colW/2, 24 * HOUR_H);
    }
    d.setDate(d.getDate() + 1);
  }
  
  textAlign(RIGHT, CENTER); textSize(11); fill(COL_TEXT_SUB);
  for (let i = 0; i <= 24; i++) {
    let y = i * HOUR_H; stroke(COL_LINE); line(SIDEBAR_W, y, width, y); noStroke(); text(`${i}:00`, SIDEBAR_W - 10, y);
    if (i < 24) { stroke(240); line(SIDEBAR_W, y + HOUR_H/2, width, y + HOUR_H/2); }
  }
  stroke(COL_LINE); for (let i = 0; i <= visibleDays; i++) line(SIDEBAR_W + i * colW, 0, SIDEBAR_W + i * colW, 24 * HOUR_H);
}

// ★ 予実管理対応 Event描画
function drawEvents() {
  let today = new Date(); today.setHours(0,0,0,0);
  for (let e of events) {
    let d = new Date(e.dateStr); d.setHours(0,0,0,0);
    let offset = getDayOffset(d);
    
    if (offset >= 0 && offset < visibleDays) {
      let isSplit = d <= today;
      drawEventRect(e, offset, isSplit);
    }
  }
}

function drawEventRect(e, offset, isSplit) {
  let colW = (width - SIDEBAR_W) / visibleDays;
  let x = SIDEBAR_W + offset * colW;
  let w = colW;
  
  // 予実分割計算
  if (isSplit) {
    w = colW / 2;
    if (e.type === 1) x += w; // Actualは右側
  } else {
    if (e.type === 1) return; // 未来の実績は非表示
  }
  
  let y = e.start * HOUR_H;
  let h = e.duration * HOUR_H;
  let pad = 4;
  
  noStroke(); fill(0, 20); rect(x+pad+2, y+2, w-pad*2, h, 4);
  
  fill(EVENT_COLORS[e.colorIdx]);
  // 実績は少し見た目を変える（枠線）
  if (e.type === 1) { stroke(255, 150); strokeWeight(2); } else { noStroke(); }
  
  rect(x+pad, y, w-pad*2, h, 4); 
  noStroke(); strokeWeight(1);
  fill(0, 50); rect(x+pad, y, 5, h, 4, 0, 0, 4);
  
  if (e === selectedItem) { noFill(); stroke(0); strokeWeight(2); rect(x+pad, y, w-pad*2, h, 4); strokeWeight(1); noStroke(); }
  
  fill(255); textAlign(LEFT, TOP);
  // クリップ代わりの簡易表示
  if (h > 20) { textSize(11); textStyle(BOLD); text(e.title, x+pad+8, y+4); }
  if (h > 40) { textSize(10); textStyle(NORMAL); text(`${formatTime(e.start)}`, x+pad+8, y+20); }
}

// --- タスク描画 ---
function drawTaskList() {
  let fullH = height - CONTROL_H; let colW = width / 3;
  noStroke();
  fill(COL_DOING_BG);   rect(0, 0, colW, fullH);
  fill(COL_BACKLOG_BG); rect(colW, 0, colW, fullH);
  fill(COL_DONE_BG);    rect(colW*2, 0, colW, fullH);
  stroke(COL_LINE); strokeWeight(2); line(colW, 0, colW, fullH); line(colW*2, 0, colW*2, fullH); strokeWeight(1);
  
  fill(COL_TEXT_SUB); textAlign(CENTER, TOP); textSize(14); textStyle(BOLD);
  text(`現在取り組んでいること (${doingTasks.length})`, colW/2, 10);
  text(`今後増えること (${backlogTasks.length})`, colW*1.5, 10);
  text(`終わったもの (${doneTasks.length})`, colW*2.5, 10);
  
  push(); translate(0, taskScrollY);
  let itemH = 60; let margin = 40; let gap = 10; let cardW = colW - 30;
  
  drawTaskItems(doingTasks, 15, margin, cardW, itemH, gap);
  drawTaskItems(backlogTasks, colW + 15, margin, cardW, itemH, gap);
  drawTaskItems(doneTasks, colW*2 + 15, margin, cardW, itemH, gap, true);
  pop();
  
  if (isTaskDragging && draggingItem) {
    drawTaskCard(draggingItem, mouseX - cardW/2, mouseY - CONTROL_H + taskDragOffsetY, cardW, itemH);
  }
}

function drawTaskItems(list, x, startY, w, h, gap, showDeleteDate=false) {
  for (let i = 0; i < list.length; i++) {
    let t = list[i];
    if (t === draggingItem) continue;
    let y = startY + i * (h + gap);
    drawTaskCard(t, x, y, w, h);
    if (showDeleteDate && t.completedDate) {
      let delD = new Date(t.completedDate); delD.setDate(delD.getDate() + 7);
      fill(COL_TEXT_SUB); textSize(10); textAlign(RIGHT, BOTTOM);
      text(`削除: ${delD.getMonth()+1}/${delD.getDate()}`, x + w, y + h + 10);
    }
  }
}

function drawTaskCard(t, x, y, w, h) {
  noStroke(); fill(0, 10); rect(x+3, y+3, w, h, 8); fill(255); rect(x, y, w, h, 8);
  fill(TASK_COLORS[t.colorIdx]); rect(x, y, 8, h, 8, 0, 0, 8);
  if (t === selectedItem) { noFill(); stroke(COL_ACCENT); strokeWeight(2); rect(x, y, w, h, 8); strokeWeight(1); noStroke(); }
  fill(COL_TEXT_MAIN); textAlign(LEFT, CENTER); textSize(14); textStyle(BOLD); text(t.title, x+20, y+h/2-8);
  fill(COL_TEXT_SUB); textSize(11); textStyle(NORMAL); text(`締切: ${t.deadline}`, x+20, y+h/2+10);
}

// --- 入力イベント ---
function setupKeyEvents() {
  document.getElementById('password-input').addEventListener('keydown', function(e) {
    if (e.key === 'Enter') checkLogin();
  });
  const inputs = ['input-title', 'input-start', 'input-end', 'input-deadline'];
  inputs.forEach(id => {
    document.getElementById(id).addEventListener('keydown', function(e) {
      if (e.key === 'Enter') saveItem();
    });
  });
  document.getElementById('input-deadline').addEventListener('keydown', function(e) {
    if (e.key === 'ArrowUp') { changeDate(1); e.preventDefault(); } 
    else if (e.key === 'ArrowDown') { changeDate(-1); e.preventDefault(); }
  });
}

function changeDate(delta) {
  let input = document.getElementById('input-deadline');
  if (input.value) {
    let d = new Date(input.value); d.setDate(d.getDate() + delta);
    input.value = formatDateISO(d);
  }
}

function doubleClicked() {
  if (document.getElementById('modal-overlay').style.display === 'flex') return;
  if (mouseY < CONTROL_H) return;

  if (currentMode === 0) {
    let colW = (width - SIDEBAR_W) / visibleDays;
    let today = new Date(); today.setHours(0,0,0,0);
    
    for (let i = events.length - 1; i >= 0; i--) {
      let e = events[i];
      let d = new Date(e.dateStr); d.setHours(0,0,0,0);
      let offset = getDayOffset(d);
      if (offset < 0 || offset >= visibleDays) continue;
      
      let isSplit = d <= today;
      let w = isSplit ? colW / 2 : colW;
      let x = SIDEBAR_W + offset * colW;
      if (isSplit && e.type === 1) x += w;
      if (!isSplit && e.type === 1) continue;
      
      let y = CONTROL_H + DATE_H + scrollY + e.start * HOUR_H;
      let h = e.duration * HOUR_H;
      
      if (mouseX >= x && mouseX <= x + w && mouseY >= y && mouseY <= y + h) {
        openModal(e, 'event'); return false;
      }
    }
  } else {
    let colW = width / 3; let itemH = 60; let margin = 40; let gap = 10;
    let zone = Math.floor(mouseX / colW);
    let targetList = (zone===0) ? doingTasks : (zone===1) ? backlogTasks : doneTasks;
    let localY = mouseY - CONTROL_H - taskScrollY - margin;
    let index = Math.floor(localY / (itemH + gap));
    if (index >= 0 && index < targetList.length) {
      openModal(targetList[index], 'task'); return false;
    }
  }
}

function mousePressed() {
  if (document.getElementById('modal-overlay').style.display === 'flex') return;
  if (!isLoggedIn) return;
  let btnClicked = false;
  buttons.forEach(b => {
    let bx = b.alignRight ? width + b.x : b.x;
    if (currentMode === 1) { if (['Day','4 Days','Week','<<','<','>','>>','今日'].includes(b.label)) return; }
    if (mouseX >= bx && mouseX <= bx + b.w && mouseY >= b.y && mouseY <= b.y + b.h) { b.action(); btnClicked = true; }
  });
  if (btnClicked) return;
  if (mouseY < CONTROL_H) return;

  if (currentMode === 0) {
    if (mouseX < SIDEBAR_W) return;
    let globalY = mouseY - CONTROL_H - DATE_H - scrollY;
    let timeVal = snapTo15Min(globalY / HOUR_H);
    let colW = (width - SIDEBAR_W) / visibleDays;
    let dayIndex = Math.floor((mouseX - SIDEBAR_W) / colW);
    
    let d = new Date(viewStartDate); d.setDate(d.getDate() + dayIndex); d.setHours(0,0,0,0);
    let today = new Date(); today.setHours(0,0,0,0);
    let isSplit = d <= today;
    
    let clickedType = 0; 
    if (isSplit) { let relX = (mouseX - SIDEBAR_W) % colW; if (relX > colW/2) clickedType = 1; }
    
    let clicked = null;
    for (let i = events.length - 1; i >= 0; i--) {
      let e = events[i];
      let ed = new Date(e.dateStr); ed.setHours(0,0,0,0);
      let offset = getDayOffset(ed);
      if (offset < 0 || offset >= visibleDays) continue;
      if (isSplit && e.type !== clickedType) continue;
      if (!isSplit && e.type === 1) continue;
      
      let w = isSplit ? colW/2 : colW;
      let x = SIDEBAR_W + offset * colW + (e.type===1 && isSplit ? w : 0);
      let y = CONTROL_H + DATE_H + scrollY + e.start * HOUR_H;
      let h = e.duration * HOUR_H;
      
      if (mouseX >= x && mouseX <= x + w && mouseY >= y && mouseY <= y + h) {
        clicked = e;
        let relY = mouseY - y;
        if (relY < RESIZE_MARGIN) dragAction = 3; else if (relY > h - RESIZE_MARGIN) dragAction = 4;
        else { dragAction = 2; dragOffsetTime = timeVal - e.start; }
        break;
      }
    }
    
    if (clicked) { selectedItem = clicked; } 
    else {
      if (dayIndex >= 0 && dayIndex < visibleDays && timeVal >= 0 && timeVal < 24) {
        let newType = clickedType; if (!isSplit) newType = 0;
        creatingEvent = new Event(formatDateISO(d), timeVal, 1.0, "新規" + (newType===0?"予定":"実績"), 0, newType);
        selectedItem = creatingEvent; dragAction = 1;
      }
    }
  } else {
    let colW = width / 3; let itemH = 60; let margin = 40; let gap = 10;
    let localY = mouseY - CONTROL_H - taskScrollY - margin;
    let index = Math.floor(localY / (itemH + gap));
    let zone = Math.floor(mouseX / colW);
    let targetList = (zone===0) ? doingTasks : (zone===1) ? backlogTasks : doneTasks;
    
    if (index >= 0 && index < targetList.length) {
      selectedItem = targetList[index];
      draggingItem = selectedItem; isTaskDragging = true;
      let itemTop = margin + index * (itemH + gap) + taskScrollY;
      taskDragOffsetY = itemTop - (mouseY - CONTROL_H);
    } else {
      if (zone !== 2) {
        let newTask = new Task("新しいタスク", formatDateISO(new Date()), "", 2);
        targetList.push(newTask); selectedItem = newTask; openModal(newTask, 'task'); saveData();
      }
    }
  }
}

function mouseDragged() {
  if (document.getElementById('modal-overlay').style.display === 'flex') return;
  if (currentMode === 0) {
    if (dragAction === 0) return;
    let globalY = mouseY - CONTROL_H - DATE_H - scrollY;
    let rawTime = globalY / HOUR_H; let snapTime = snapTo15Min(rawTime);
    let colW = (width - SIDEBAR_W) / visibleDays;
    let dayIndex = Math.floor((mouseX - SIDEBAR_W) / colW);
    if (dayIndex < 0) dayIndex = 0; if (dayIndex >= visibleDays) dayIndex = visibleDays - 1;
    let d = new Date(viewStartDate); d.setDate(d.getDate() + dayIndex);
    
    if (dragAction === 1 && creatingEvent) {
      let dur = snapTime - creatingEvent.start; if (dur < 0.25) dur = 0.25; creatingEvent.duration = dur;
    } else if (selectedItem) {
      if (dragAction === 2) {
        let newStart = snapTo15Min(rawTime - dragOffsetTime); if (newStart < 0) newStart = 0;
        if (newStart + selectedItem.duration > 24) newStart = 24 - selectedItem.duration;
        selectedItem.start = newStart; selectedItem.dateStr = formatDateISO(d);
      } else if (dragAction === 3) {
        let oldEnd = selectedItem.start + selectedItem.duration; let newStart = snapTime;
        if (newStart > oldEnd - 0.25) newStart = oldEnd - 0.25; selectedItem.start = newStart; selectedItem.duration = oldEnd - newStart;
      } else if (dragAction === 4) {
        let newEnd = snapTime; let newDur = newEnd - selectedItem.start;
        if (newDur < 0.25) newDur = 0.25; selectedItem.duration = newDur;
      }
    }
  }
}

function mouseReleased() {
  if (currentMode === 0) {
    if (dragAction === 1 && creatingEvent) {
      events.push(creatingEvent); selectedItem = creatingEvent;
      // ★自動コピー処理 (Plan->Actual)
      let d = new Date(creatingEvent.dateStr); d.setHours(0,0,0,0);
      let today = new Date(); today.setHours(0,0,0,0);
      if (creatingEvent.type === 0 && d <= today) {
        let copy = new Event(creatingEvent.dateStr, creatingEvent.start, creatingEvent.duration, creatingEvent.title, creatingEvent.colorIdx, 1);
        copy.memo = creatingEvent.memo; events.push(copy);
      }
      openModal(selectedItem, 'event'); creatingEvent = null;
    }
    dragAction = 0; saveData();
  } else {
    if (isTaskDragging && draggingItem) {
      let colW = width / 3; let dropZone = Math.floor(mouseX / colW);
      removeFromAllLists(draggingItem);
      if (dropZone === 0) { doingTasks.push(draggingItem); draggingItem.completedDate = ""; }
      else if (dropZone === 1) { backlogTasks.push(draggingItem); draggingItem.completedDate = ""; }
      else { doneTasks.unshift(draggingItem); if (!draggingItem.completedDate) draggingItem.completedDate = formatDateISO(new Date()); }
      openModal(draggingItem, 'task');
      isTaskDragging = false; draggingItem = null; saveData();
    }
  }
}

function mouseWheel(event) {
  if (document.getElementById('modal-overlay').style.display === 'flex') return;
  let d = event.deltaY;
  if (currentMode === 0) {
    scrollY -= d;
    let maxH = 24 * HOUR_H; let viewH = height - CONTROL_H - DATE_H;
    if (scrollY > 0) scrollY = 0; if (scrollY < viewH - maxH) scrollY = viewH - maxH;
  } else {
    taskScrollY -= d;
    if (taskScrollY > 0) taskScrollY = 0;
    let maxCount = Math.max(doingTasks.length, backlogTasks.length, doneTasks.length);
    let contentH = maxCount * 70 + 100;
    let viewH = height - CONTROL_H;
    if (taskScrollY < viewH - contentH) taskScrollY = viewH - contentH;
    if (contentH < viewH) taskScrollY = 0;
  }
}

// --- Utils ---
function openModal(item, type) {
  selectedItem = item;
  let modal = document.getElementById('modal-overlay');
  let headerBar = document.getElementById('modal-header-bar');
  let colorPicker = document.getElementById('color-picker');
  modal.style.display = 'flex';
  
  document.getElementById('input-title').value = item.title;
  document.getElementById('input-memo').value = item.memo;
  
  colorPicker.innerHTML = '';
  let colors = (type === 'event') ? EVENT_COLORS : TASK_COLORS;
  
  colors.forEach((c, idx) => {
    let div = document.createElement('div');
    div.className = 'color-circle' + (idx === item.colorIdx ? ' selected' : '');
    div.style.backgroundColor = c;
    div.onclick = () => {
      item.colorIdx = idx;
      headerBar.style.background = c;
      Array.from(colorPicker.children).forEach((child, i) => {
        if(i === idx) child.classList.add('selected'); else child.classList.remove('selected');
      });
    };
    colorPicker.appendChild(div);
  });
  headerBar.style.background = colors[item.colorIdx];

  if (type === 'event') {
    document.getElementById('label-title').innerText = (item.type===1) ? "実績タイトル" : "予定タイトル";
    document.getElementById('group-time').style.display = 'block';
    document.getElementById('group-deadline').style.display = 'none';
    document.getElementById('input-start').value = formatTimeInput(item.start);
    document.getElementById('input-end').value = formatTimeInput(item.start + item.duration);
  } else {
    document.getElementById('label-title').innerText = "タスク名";
    document.getElementById('group-time').style.display = 'none';
    document.getElementById('group-deadline').style.display = 'block';
    document.getElementById('input-deadline').value = item.deadline;
  }
}

function saveItem() {
  if (!selectedItem) return;
  selectedItem.title = document.getElementById('input-title').value;
  selectedItem.memo = document.getElementById('input-memo').value;
  if (currentMode === 0) {
    let s = parseTimeInput(document.getElementById('input-start').value);
    let e = parseTimeInput(document.getElementById('input-end').value);
    if (s >= 0 && e > s) { selectedItem.start = s; selectedItem.duration = e - s; }
  } else {
    selectedItem.deadline = document.getElementById('input-deadline').value;
  }
  saveData(); closeModal();
}

function deleteItem() {
  if (!selectedItem) return;
  if (currentMode === 0) { events = events.filter(e => e !== selectedItem); }
  else { removeFromAllLists(selectedItem); }
  selectedItem = null; saveData(); closeModal();
}
function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
function toggleMode() { currentMode = (currentMode === 0) ? 1 : 0; }

function loadData() {
  let svE = localStorage.getItem('calendar_events'); 
  if(svE) {
    let raw = JSON.parse(svE);
    events = raw.map(e => {
      let nev = new Event(e.dateStr, e.start||0, e.duration||1, e.title||"", e.colorIdx||0, e.type !== undefined ? e.type : 0);
      nev.memo = e.memo || ""; return nev;
    });
    // 自動同期: 過去/今日のPlanでActualがない場合、自動生成
    let today = new Date(); today.setHours(0,0,0,0);
    let actualKeys = new Set();
    events.filter(e => e.type === 1).forEach(e => actualKeys.add(e.dateStr + "_" + e.title));
    let newActuals = [];
    events.forEach(e => {
      if(e.type === 0) {
        let d = new Date(e.dateStr); d.setHours(0,0,0,0);
        if(d <= today) {
          let key = e.dateStr + "_" + e.title;
          if(!actualKeys.has(key)) {
            let cp = new Event(e.dateStr, e.start, e.duration, e.title, e.colorIdx, 1);
            cp.memo = e.memo; newActuals.push(cp);
          }
        }
      }
    });
    events = events.concat(newActuals);
  }
  
  let svB = localStorage.getItem('task_backlog'); if(svB) backlogTasks = JSON.parse(svB).map(t => Object.assign(new Task(), t));
  let svD = localStorage.getItem('task_doing'); if(svD) doingTasks = JSON.parse(svD).map(t => Object.assign(new Task(), t));
  let svF = localStorage.getItem('task_done'); if(svF) doneTasks = JSON.parse(svF).map(t => Object.assign(new Task(), t));
  
  let oneWeekAgo = new Date(); oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
  doneTasks = doneTasks.filter(t => { if (!t.completedDate) return true; return new Date(t.completedDate) >= oneWeekAgo; });
}
function saveData() {
  localStorage.setItem('calendar_events', JSON.stringify(events));
  localStorage.setItem('task_backlog', JSON.stringify(backlogTasks));
  localStorage.setItem('task_doing', JSON.stringify(doingTasks));
  localStorage.setItem('task_done', JSON.stringify(doneTasks));
}

function moveDate(days) { viewStartDate.setDate(viewStartDate.getDate() + days); }
function getDayOffset(date) { let diff = date - viewStartDate; return Math.floor(diff / (1000 * 60 * 60 * 24)); }
function isSameDate(d1, d2) { return d1.getFullYear()===d2.getFullYear() && d1.getMonth()===d2.getMonth() && d1.getDate()===d2.getDate(); }
function isPastOrToday(d) { let today = new Date(); today.setHours(0,0,0,0); d.setHours(0,0,0,0); return d <= today; }
function formatDateISO(d) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function formatTime(val) { let h = Math.floor(val); let m = Math.round((val - h) * 60); return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`; }
function formatTimeInput(val) { return formatTime(val); }
function parseTimeInput(str) { let parts = str.split(':'); if (parts.length === 2) return parseInt(parts[0]) + parseInt(parts[1])/60; return 0; }
function snapTo15Min(val) { return Math.round(val / 0.25) * 0.25; }
function removeFromAllLists(t) { backlogTasks = backlogTasks.filter(x => x !== t); doingTasks = doingTasks.filter(x => x !== t); doneTasks = doneTasks.filter(x => x !== t); }
function getDayName(i) { return ['日','月','火','水','木','金','土'][i]; }
function updateCursor() { if (showModal) { cursor(ARROW); return; } if (currentMode === 0) { if (dragAction === 2) cursor(MOVE); else if (dragAction >= 3) cursor(HAND); else cursor(ARROW); } else { cursor(isTaskDragging ? MOVE : ARROW); } }

function exportICS() {
  let calContent = "BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//My Web App//EN\n";
  events.forEach(e => {
    if (e.type === 1) return;
    let d = new Date(e.dateStr);
    let sH = Math.floor(e.start); let sM = Math.round((e.start - sH) * 60);
    let eH = Math.floor(e.start + e.duration); let eM = Math.round((e.start + e.duration - eH) * 60);
    let dtStart = formatICSDate(d, sH, sM); let dtEnd = formatICSDate(d, eH, eM);
    calContent += "BEGIN:VEVENT\n" + `DTSTART:${dtStart}\n` + `DTEND:${dtEnd}\n` + `SUMMARY:${e.title}\n` + `DESCRIPTION:${e.memo.replace(/\n/g, '\\n')}\n` + "END:VEVENT\n";
  });
  calContent += "END:VCALENDAR";
  let blob = new Blob([calContent], { type: 'text/calendar' });
  let url = URL.createObjectURL(blob); let a = document.createElement('a'); a.href = url; a.download = 'schedule.ics'; a.click();
}
document.getElementById('file-input').addEventListener('change', function(e) {
  let file = e.target.files[0]; if (!file) return;
  let reader = new FileReader();
  reader.onload = function(e) { parseICS(e.target.result); }; reader.readAsText(file);
});
function parseICS(text) {
  let lines = text.split(/\r\n|\n|\r/); let inEvent = false; let tempEvent = {};
  lines.forEach(line => {
    if (line.startsWith('BEGIN:VEVENT')) { inEvent = true; tempEvent = {title:"No Title", memo:"", duration:1, type:0}; }
    else if (line.startsWith('END:VEVENT')) { if (inEvent && tempEvent.start) events.push(new Event(tempEvent.dateStr, tempEvent.start, tempEvent.duration, tempEvent.title, 0, 0)); inEvent = false; }
    else if (inEvent) {
      if (line.startsWith('SUMMARY:')) tempEvent.title = line.substring(8);
      else if (line.startsWith('DESCRIPTION:')) tempEvent.memo = line.substring(12).replace(/\\n/g, '\n');
      else if (line.startsWith('DTSTART')) {
        let val = line.split(':')[1]; let p = parseICSDate(val);
        tempEvent.dateStr = formatDateISO(p.d); tempEvent.start = p.h + p.m/60;
      }
    }
  });
  saveData(); alert('インポート完了');
}
function formatICSDate(d, h, m) { return `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}T${String(h).padStart(2,'0')}${String(m).padStart(2,'0')}00`; }
function parseICSDate(str) {
  let y = parseInt(str.substring(0,4)); let m = parseInt(str.substring(4,6))-1; let d = parseInt(str.substring(6,8));
  let h = 0, min = 0;
  if (str.includes('T')) { let tPart = str.split('T')[1]; h = parseInt(tPart.substring(0,2)); min = parseInt(tPart.substring(2,4)); }
  return { d: new Date(y,m,d), h: h, m: min };
}
</script>
</body>
</html>